# Writing a PLUGIN

[Note: the code may change continually, so refer to that for latest versions.]
## Overview

We illustrate how to write a plugin by creating one for searching for sequences in full text. We allow for a variety, DNA
RNA, 3-letter protein, 1-letter protein, Carbohydrates. It should be easily modifiable and upgradable.

We need to create the following interdependent components. The naming is important and inconsistencies will cause problems. We
take `sequence` as the unique "plugin name". It will occur in at least:

 * configuration filenames (e.g. `/org/xmlcml/ami2/plugins/sequence/args.xml`. This drives the operation of the program. It's a path relative to the Java classpath and is usually found as `src/main/resources/org/xmlcml/ami2/plugins/sequence/args.xml`. 
 * autogenerated directories `my_file/some_where/results/sequence/dna/results.xml`. `my_file/some_where/` is a QSN directory, abd after the calculation, the plugin `sequence`  generates (or uses an existing) `results` (reserved name) directory. Then it generates the subdirectory `sequence` (using the plugin name) and then plugin-specific subsubdirectories.
 * classes (e.g. `SequenceArgProcessor`). The functionality of `args.xml` and the Java class must be carefully matched (see below)
 * argument definitions in `args.xml`. These will be used to control action and generate files and will frequently use the pluginName.
 
We shall build checkers and autogenerators to aid consistency, but for now be extra careful and check. 

## Inheritance

We have the following inheritance hierarchy (discussed in detail in  and AMI.md)

```
    DefaultArgProcessor
        AMIArgProcessor
            SequenceArgProcessor
```

### DefaultArgProcessor

This contains all generic parsing software, general flow , input and output. See DEFAULT.md)

### AMIArgProcessor

This contains generic plugin parsing software, such as text contexts, output options, choice of inputs. See AMI.md)

## design

Each option will probably need an `<arg>`.

We want to control at least

 * The type of sequence
 * the lengths of sequences
 * lookup in repositories
 
## args.xml

Much of the generic functionality (input, parsing, etc.) is inherited, so we can concentrate on the functionallity for sequences. The structure of the file is

```
<argList name="sequence">
    <arg name="type" ...
    <arg name="...
</argList>
```

Each arg represents a possible argument (starting with `-` or `--`). It has a name, constraints on occurrence numbers, constraints on values, Java type, default values, actions when triggered, etc.

### Sequence type

This describes the biological type of the sequence. (Note we'll use lowercase throughout). We'll do this through a `pattern` which allows only listed keywords. We'll only allow one type at present - if you want to search for DNA and Protein, run independent searches - they can always be merged later. Note that the attributes (name="value") can be in any order but the same attribute name cannot occur more than once.

```
<arg name="type"
    brief="-sq.t"
    long="--sq.type"
    args="type"
    default="dna"
    class="java.lang.String"
    pattern="(dna|rna|prot|prot3|carb3)"
    parseMethod="parseType"
    countRange="{1,1}"
    >
    <help>
    The type of the sequence. All sequences are 1-letter unless they have a trailing digit.
    </help>
```

Comments:

 * the `name` must be unique in this plugin and may be useful to create output subdirectories
 * the flags (`brief` and `long`) must be unique within the job. `long` is mandatory and recommended; it starts with 2 minus signs. `brief` cannot normally be condensed to single letters (which themselves cannot be concatenated). 
 * `args` is a semi-formatted string to prompt the user on possible arguments.
 * `default` provides a default value which must be of the same class as the argument value, and must be consistent with any constraints.
 * `class` is the Java data type of the argument value. By default it is a `String` (of text) - formally `java.lang.String`. Other common `java.lang.*` values are `Boolean`, `Integer` and `Double`. 
 * `pattern` is a constraint on the argument values. In this case it's a regular expression describing an enumeration of allowed values.
 * `countRange` constraints the number of values for the argument. In this case it's minimum of 1, maximum of 1, so 1.
 * `parseMethod` is mandatory for every argument, and names the Java class used to parse this argument. In many cases it's a single line assigning the value (although it can be more complex).
 
 ### sequence length
 
 To constrain the length of the sequence we can set minimum and/or maximum length. "don't care" is represented by `*`. Examples:
 
  * `countRange="{6,20}"`   sequences of length 6 to 20 inclusive
  * `countRange="{*,20}"`   sequences of length up to 20 
  * `countRange="{6,*}"`   sequences of length 6 or more
  * `countRange="{*,*}"`   sequences of any length 
  
  The `<arg>` looks  like
  
  ```
<arg name="length"
    brief="-sq.l"
    long="--sq.length"
    args="lengthRange"
    default="{1,*}"
    class="org.xmlcml.euclid.IntRange"
    parseMethod="parseLength"
    countRange="{1,1}"
    >
    <help>
    The allowed length of the sequence, described by a single org.xmlcml.euclid.IntRange (note there are no internal spaces). The default is `{1,*}` - any non-empty sequence - will be used if there is no `--sq.length` attribute. When this attribute is present, the method `parseLength` will be called which saves the value of the `IntRange`.
    </help>
```

  
  
  
